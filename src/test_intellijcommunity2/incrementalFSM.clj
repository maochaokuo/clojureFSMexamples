(ns test-intellijcommunity2.incrementalFSM
  (:require [reduce-fsm :as fsm]))

; Incremental FSM
; The following example repeats the state machine from the Basic FSM example but uses function calls to provide events instead of clojure sequences. This can be useful when you have multiple event sources or events are generated by callbacks.

(defn inc-val [val & _] (inc val))

(fsm/defsm-inc count-ab
               [[:start
                 \a -> :found-a]
                [:found-a
                 \a ->  :found-a
                 \b -> {:action inc-val} :start
                 _ -> :start]])

;; create an instance of the fsm with an initial value of 0
(def fsm-state (atom (count-ab 0)))

;; update the state with a few events
(swap! fsm-state fsm/fsm-event \a)
(swap! fsm-state fsm/fsm-event \a)
(swap! fsm-state fsm/fsm-event \b)

(comment
  (:value @fsm-state)
  ;; returns the current accumulated value => 1

  (:state @fsm-state)
  ;; the current state of the fsm => :start

  ;; count the number of ab occurences in a string
  (:value (reduce fsm/fsm-event (count-ab 0) "abaaabc"))
  ;; => 2

  (fsm/show-fsm count-ab)
  ;; displays the fsm diagram below
  )
